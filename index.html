<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Home page</title>
</head>
<body>
    <hr>
    <Table>
        <tr>
            <td>
                <table>
                    <tr>
                        <td> <img src="index/Frozen-logo.png" alt="logo not found"></td>
                        <td><h2>FROZEN <br>CREATION </h2></td>
                    </tr>
                </table>
            </td>
            <td align="right">
                <table align="right">
                    <td><button>Home</button></td>
                    <td><button>Services</button></td>
                    <td><button>Portfolio</button></td>
                    <td><button>About</button></td>
                    <td><button>Blogs</button></td>
                </table>
            </td>
        </tr>
    </Table>
    <h1>The Complete Marketing <br> Destination For All Your <br> Needs!</h1>
    <p>
    
    <hr>1. To write a JAVA program to perform binary search using the divide and conquer technique.  <br><br>
Aim- Program to implement Binary Search using Divide and Conquer  <br>
Algo-  <br>
Step 1: Start the process.  <br>
Step 2: Declare the variables.  <br>
Step 3: Enter the list of elements to be searched.  <br>
Step 4: Divide the array list into two halves the lower array list and upper array list.  <br>
Step 5: It works by comparing a search key k with the arrays middle element a[m].  <br>
Step 6: If they match the algorithm stops; otherwise the same operation is repeated  <br>
recursively for the first half of the array if k < a[m] and the second half if k > a[m].  <br>
Step 7: Display the searching results  <br>
Step 8: Stop the process.  <br><br>
        public class Binarysearch<br>
{<br>

int binarysearch(int arr[],int size, int key) {<br>
int start=0;<br>
int end=size-1;<br>
int mid=(start+end)/2;<br>
while(start<=end)<br>
{<br>
if(arr[mid]==key)<br>
{ return mid;<br>
}<br>
if(key>arr[mid])<br>
{<br>
start=mid+1;<br>
}<br>
else<br>
{<br>
end=mid-1;<br>
}<br>
mid=(start+end)/2;<br>

}<br>
return -1;<br>

}<br>
public static void main(String args[]) {<br>
Binarysearch ob=new Binarysearch();<br>
int even[]= {2,4,6,8,12,15};<br>
int odd[]= {3,5,8,6,11};<br>
int index=ob.binarysearch(even,6,12);<br>
System.out.println("index of 12 is "+ index);<br>
int oddindex=ob.binarysearch(odd,5,5);<br>
System.out.println("index of 5 is "+ oddindex);<br>
}<br>

}<br><br>
Program to search a name in an array :-<br>
public class Binarysearch<br>
{<br>
static String[] a = { "Shailesh", "Hajarilal", "Agrawal"};<br>
static int min = 0;<br>
static int max = a.length - 1;<br>
static int mid;<br>
static String key = "Hajarilal";<br>
public static void main(String[] args) {<br>
System.out.println("Key Found at : " +<br>

stringBinarySearch() + " position");<br>
}<br>
public static int stringBinarySearch() {<br>
while (min <= max) {<br>
mid = (min + max) / 2;<br>
if (a[mid].compareTo(key) < 0) { min = mid + 1; }<br>
else if (a[mid].compareTo(key) > 0) {<br>

max = mid - 1;}<br>
else {<br>
return mid; }<br>

}<br>
return -1;<br>
}<br>
}		<br><hr><br>
2. To write a JAVA program to perform merge sort using the divide
and conquer technique.(time complexcity O(n*logn).)<br><br>
Aim: Program to implement Merge Sort using Divide and Conquer<br>Alg-<br>
Step 1:Split array A[1..n] in two and make copies of each half in arrays B[1.. n/2 ] and
C[1..n/2 ]<br>
Step 2: Sort arrays B and C<br>
Step 3: Merge sorted arrays B and C into array A as follows:<br>
i. Repeat the following until no elements remain in one of the arrays:<br>
 compare the first elements in the remaining unprocessed portions of the arrays<br>
 copy the smaller of the two into A, while incrementing the index indicating the
unprocessed portion of that array<br>
ii. Once all elements in one of the arrays are processed, copy the remaining
unprocessed elements from the other array into A.<br>

public class Mergesort {<br>
void merge(int arr[], int l, int m, int r)<br>
{<br>
int n1 = m - l + 1;<br>
int n2 = r - m;<br>
int L[] = new int[n1];<br>
int R[] = new int[n2];<br>
for (int i = 0; i < n1; ++i)<br>
L[i] = arr[l + i];<br>
for (int j = 0; j < n2; ++j)<br>
R[j] = arr[m + 1 + j];<br>
int i = 0, j = 0;<br>
int k = l;<br>
while (i < n1 && j < n2) {<br>
if (L[i] <= R[j]) {<br>
arr[k] = L[i];<br>
i++;<br>
}<br>
else {<br>
arr[k] = R[j];<br>
j++;<br>
}<br>
k++;<br>
}<br>
while (i < n1) {<br>
arr[k] = L[i];<br>
i++;<br>
k++;<br>
}<br>
while (j < n2) {<br>
arr[k] = R[j];<br>
j++;<br>
k++;<br>
}<br>
}<br>
void sort(int arr[], int l, int r)<br>
{<br>
if (l < r) {<br>
int m = l + (r - l) / 2;<br>
sort(arr, l, m);<br>
sort(arr, m + 1, r);<br>
merge(arr, l, m, r);<br>
}<br>
}<br>
static void printArray(int arr[])	<br>
{<br>
int n = arr.length;<br>
for (int i = 0; i < n; ++i)<br>
System.out.print(arr[i] + " ");<br>
System.out.println();<br>
}<br>
public static void main(String args[])<br>
{<br>
int arr[] = { 12, 11, 13, 5, 6, 7 };<br>
System.out.println("Given Array");<br>
printArray(arr);<br>
Mergesort ob = new Mergesort();<br>
ob.sort(arr, 0, arr.length - 1);<br>
System.out.println("\nSorted array");<br>
printArray(arr);<br>
}<br>
}<br><hr><br>

3. To write a JAVA program to perform Heap sort using the divide
and conquer technique.[O(n log n)]<br><br>
Aim: Program to implement Heap Sort<br>
Alg-<br>
Step 1 - Construct a Binary Tree with given list of Elements.<br>
Step 2 - Transform the Binary Tree into max Heap.<br>
Step 3 - Delete the root element from Max Heap using Heapify method.<br>
Step 4 - Put the deleted element into the Sorted list.<br>
Step 5 - Repeat the same until Max Heap becomes empty.<br>
Step 6 - Display the sorted list.    <br><br>
public class HeapSort {    <br>
public void sort(int arr[])    <br>
{    <br>
int N = arr.length;    <br>
for (int i = N / 2 - 1; i >= 0; i--)    <br>
heapify(arr, N, i);    <br>
for (int i = N - 1; i > 0; i--) {    <br>
int temp = arr[0];    <br>
arr[0] = arr[i];    <br>
arr[i] = temp;    <br>
heapify(arr, i, 0);    <br>
}    <br>
}    <br>
void heapify(int arr[], int N, int i)    <br>
{    <br>
int largest = i;    <br>
int l = 2 * i + 1;    <br>
int r = 2 * i + 2;    <br>
if (l < N && arr[l] > arr[largest])    <br>
largest = l;    <br>
if (r < N && arr[r] > arr[largest])    <br>
largest = r;    <br>
if (largest != i) {    <br>
int swap = arr[i];    <br>
arr[i] = arr[largest];    <br>
arr[largest] = swap;    <br>
heapify(arr, N, largest);    <br>
}    <br>
}    <br>
static void printArray(int arr[])    <br>
{    <br>
int N = arr.length;    <br>
for (int i = 0; i < N; ++i)    <br>
System.out.print(arr[i] + " ");    <br>
System.out.println();    <br>
}    <br>
public static void main(String args[])    <br>
{    <br>
int arr[] = { 12, 11, 13, 5, 6, 7 };          <br>
int N = arr.length; <br>
HeapSort ob = new HeapSort(); <br>
ob.sort(arr); <br>
System.out.println("Sorted array is"); <br>
printArray(arr); <br>
} <br>
} <br><hr><br>
4. To write a JAVA program to implement Prims algorithm using
Greedy method.<br><br>
Aim: Program to implement Prim’s algorithm using Greedy method<br>
Alg-<br>        
Step 1:Start at any node in the graph<br> 
Step 2:Mark the starting node as reached<br> 
Step 3: Mark all the other nodes in the graph as unreached<br> 
Step 4: Right now, the Minimum cost Spanning Tree (MST) consists of the starting node<br> 
Step5: Find an edge e with minimum cost in the graph that connects:
A reached node x to an unreached node y<br> 
Step 6: Add the edge e found in the previous step to the Minimum cost Spanning Tree<br> 
Step 7: Mark the unreached node y as reached<br> 
Step 8: Repeat the steps 2 and 3 until all nodes in the graph have become reached<br><br>      
import java.util.*;  <br>
class Main  <br>
{          <br>
public void Prim(int G[][], int V)  <br>
{ int no_edge; int  <br>
selected[] = {0,0,0,0,0};  <br>
no_edge = 0;  <br>
selected[0] = 1; int  <br>
cost = 0;  <br>
System.out.println("Edge : Weight\n");  <br>
  <br>
while (no_edge < V - 1)   <br>         
{ int min =9999; int x = 0;  <br>
int y = 0;  <br>
for (int i = 0; i < V; i++)  <br>
{ if (selected[i]== 1)  <br>
{  <br>
for (int j = 0; j < V; j++)  <br>
{  <br>
if (selected[j] == 0 && G[i][j] != 0  <br>)
{ if (min  <br>
> G[i][j])  <br>
{  <br>
min = G[i][j];  <br>
x = i; y = j;  <br>
}  <br>
}  <br>
}  <br>
}    <br>
}  <br>
System.out.print(x + " - " + y + " : " + G[x][y]+"\n");  <br>
cost += G[x][y]; selected[y] = 1; no_edge++;  <br>
}  <br>
  <br>
System.out.println("Cost: "+cost);  <br>
}  <br>
public static void main(String[] args)  <br>
{  <br>
Main g = new Main();  <br>

int V = 5;  <br>
  <br>
int[][] G = { { 0, 9, 75, 7, 0 },  <br>
{ 9, 0, 95, 19, 42 },  <br>
{ 75, 95, 0, 200, 6 },  <br>
{ 0, 19, 81, 0, 3 },  <br>
{ 0, 42, 66, 1, 0 } };  <br>
  <br>
g.Prim(G, V);  <br>
}  <br>
}  <br><hr><br>
5. To write a JAVA program to implement Prims algorithm using
Greedy method. <br><br>
Aim: Program to implement Kruskals’s algorithm using Greedy method<br>
Alg-  <br>
<br>Step 1:Start at any node in the graph <br>
Step 2:Mark the starting node as reached <br>
Step 3: Mark all the other nodes in the graph as unreached <br>
Step 4: Right now, the Minimum cost Spanning Tree (MST) consists of the starting node <br>
Step5: Sort all the edges from low weight to high weight. <br>
Step 6: Take the edge with the lowest weight and use it to connect the vertices of graph. <br>
Step 7: If adding an edge creates a cycle, then reject that edge and go for the next least <br>
weight edge. <br>
Step 8: Keep adding edges until all the vertices are connected and a Minimum Spanning <br>
Tree (MST) is obtained. <br> <br>
import java.io.*;<br>
import java.lang.*;<br>
import java.util.*;<br>
<br>
class kruskals {       <br> 
class subset {<br>
int parent, rank;<br>
};       <br>
class Edge implements Comparable<Edge> {<br>
int source, destination, weight; <br>
public int compareTo(Edge that)<br>
{<br>
return this.weight - that.weight;<br>
}<br>
};        <br>
int V, E; // V is no. of vertices & E is no.of edges<br>
Edge edge[]; // collection of all edges<br>
kruskals(int v, int e)       <br>
{<br>
V = v;<br>
E = e;<br>
edge = new Edge[E];<br>
for (int i = 0; i < e; i++)<br>
edge[i] = new Edge();<br>
}      <br>
int find(subset subsets[], int i)<br>
{       <br>
if (subsets[i].parent != i)<br>
{<br>
subsets[i].parent= find(subsets, subsets[i].parent);<br>
}<br>
return subsets[i].parent;<br>
}<br>
void Union(subset subsets[], int x, int y)<br>
{<br>
int xroot = find(subsets, x);<br>
int yroot = find(subsets, y);                <br>      
if (subsets[xroot].rank < subsets[yroot].rank)<br>
subsets[xroot].parent = yroot;<br>
else if (subsets[xroot].rank > subsets[yroot].rank)<br>
subsets[yroot].parent = xroot;                    <br>
else {<br>
subsets[yroot].parent = xroot;<br>
subsets[xroot].rank++;<br>
}<br>
}<br>
void KruskalMST() <br>
{<br>
Edge result[] = new Edge[V];    <br> 
int e = 0;      <br>
int i = 0;<br>
for (i = 0; i < V; ++i)<br>
result[i] = new Edge();      <br>
Arrays.sort(edge);      <br> 
subset subsets[] = new subset[V];<br>
for (i = 0; i < V; ++i)<br>
subsets[i] = new subset();        <br>
for (int v = 0; v < V; ++v) {<br>
subsets[v].parent = v;<br>
subsets[v].rank = 0;<br>
}<br>
i = 0;        <br>
while (e < V - 1) {       <br> 
Edge next_edge = edge[i++];     <br>
int x = find(subsets, next_edge.source);<br>
int y = find(subsets, next_edge.destination);  <br>     
 if (x != y) {<br>
result[e++] = next_edge;<br>
Union(subsets, x, y);<br>
}<br>
}<br>
System.out.println("Following are the edges in "<br>
+ "the constructed MST");<br>
int minimumCost = 0;<br>
for (i = 0; i < e; ++i) {<br>
System.out.println(result[i].source + " --> "<br>
+ result[i].destination<br>
+ " == " + result[i].weight);<br>
minimumCost += result[i].weight;<br>
}<br>
System.out.println("Minimum Cost of Spanning Tree: "<br>
+ minimumCost);<br>
}<br>
<br>
public static void main(String[] args)<br>
{<br>
Scanner s = new Scanner(System.in);<br>
System.out.println("Enter the number of Vertex:");<br>
int V = s.nextInt(); // Number of vertices in graph<br>
<br>
System.out.println("Enter the number of Edges:");<br>
int E = s.nextInt(); // Number of edges in graph<br>
<br>
kruskals graph = new kruskals(V, E);<br>
<br>
Scanner sc = new Scanner(System.in);<br>
<br>
for(int i=0 ; i<E ; i++)<br>
{<br>
System.out.println("Add Edge:"+i);<br>
graph.edge[i].source =sc.nextInt();<br>
graph.edge[i].destination =sc.nextInt();<br>
graph.edge[i].weight = sc.nextInt();<br>
}<br>
<br>
graph.KruskalMST();<br>
}<br>
}       <br> 
<hr> <br>
6. To write a JAVA program to Program to implement Knapsack
problem using Dynamic Programming<br> <br>
Aim: Program to implement Knapsack problem using Greedy Approach<br>
Alg-<br>
Step 1:For each item, compute its value / weight ratio.<br>
Step 2: Arrange all the items in decreasing order of their value / weight ratio.<br>
Step 3: Start putting the items into the knapsack beginning from the item with the highest ratio.<br>
Step 4: Put as many items as you can into the knapsack.<br>
Step 5: Calculate the maximum value.<br><br>
import java.util.*;<br>
public class knapsack {<br>
static int capacity;<br>
static int n;<br>
static int max(int a, int b)<br>
{       <br>
return (a > b) ? a : b;<br>
}<br>
<br>
static void knapSack(int capapcity, int W[],<br>
int P[], int n)<br>
{<br>
int i, w;<br>
int K[][] = new int[n + 1][capacity + 1];<br>
<br>
// Build table K[][] in bottom up manner<br>
for (i = 0; i <= n; i++)<br>
{<br>
for (w = 0; w <= capacity; w++)<br>
{<br>
if (i == 0 || w == 0)<br>
K[i][w] = 0;<br>
else if (W[i - 1] <= w)<br>
K[i][w]<br>
= max(P[i - 1]<br>
+ K[i - 1][w - W[i - 1]],<br>
K[i - 1][w]);<br>
else<br>
K[i][w] = K[i - 1][w];<br>
}<br>
}       <br>
System.out.println("Maximum Profit is:"+K[n][capacity]);<br>
}<br>
<br>
public static void main(String[] args) {<br>
Scanner s=new Scanner(System.in);<br>
<br>
System.out.println("Enter the Capacity of Sack:");<br>
capacity=s.nextInt();<br>
<br>
System.out.println("Enter the Number of Items:");<br>
n=s.nextInt();<br>
int P[]=new int[10];<br>
int W[]=new int[10];<br>
<br>
System.out.println("Enter the Weight Array:");<br>
for(int i=0;i<n;i++)<br>
{<br>
W[i]=s.nextInt();<br>
}<br>
System.out.print("Weight Array:[ ");<br>
for(int j=0;j<n;j++)<br>
{<br>
System.out.print(W[j]+" ");        <br>
}<br>
System.out.println("]");<br>
System.out.println();<br>
System.out.println("Enter the Profit Array:");<br>
for(int i=0;i<n;i++)<br>
{<br>
P[i]=s.nextInt();<br>
}<br>
System.out.print("Profit Array:[ ");<br>
for(int j=0;j<n;j++)<br>
{<br>
System.out.print(P[j]+" ");<br>
}<br>
System.out.println("]");<br>
System.out.println();<br>
for(int i=0;i<n;i++)<br>
{<br>
for(int j=0;j<n;j++)<br>
{<br>
if(W[i]<W[j])<br>
{<br>
int temp=W[i];<br>
W[i]=W[j]; <br>
W[j]=temp;<br>
int temp2=P[i];<br>
P[i]=P[j];<br>
P[j]=temp2;<br>
}<br>
}<br>
}<br>
System.out.print("Sorted array of weight is:[ ");<br>
for(int i=0;i<n;i++)<br>
{<br>
System.out.print(W[i]+" ");<br>
}<br>
System.out.println("]");<br>
System.out.print("Sorted array of Profit according to Weight is:[ ");<br>
for(int i=0;i<n;i++)<br>
{<br>
System.out.print(P[i]+" ");<br>
}<br>
System.out.println("]");<br>
System.out.println();<br>
knapSack(capacity, W, P, n);<br>
}<br>
}        <br><hr><br>
7. To write a JAVA program to perform Coin changing problem       <br><br> 
Aim: Program to implement Coin changing problem    <br> 
Alg-  <br>
Step 1:Let's say Mn is the minimum number of coins needed to make the change for the value n.<br>
Step 2: Let's start by picking up the first coin i.e., the coin with the value d1d1. So, we now need to make the value of n−d1and Mn−d1is the minimum number of coins needed for this purpose. So, the total number of coins needed are 1+Mn−d1(1 coin because we already picked the coin with value d1 and Mn−d1is the
minimum number of coins needed to make the rest of the value).<br>
Step 3: Similarly, we can pick the second coin first and then attempt to get the optimal solution for the value of n−d2 which will require Mn−d2 coins and thus a total of 1+Mn−d2.<br>
Step 4: We can repeat the process with all the k coins and then the minimum value of all these will be our answer. i.e., mini:di≤n{Mn−di+1}.<br>
Step 5: But the real problem is that we don't know the value of x. So, we will try every coin for the value of x and then we will select the minimum among those.<br>
Mn={mini:di≤n{Mn−di+1},if n>0<br>
0, if n=0<br>
You can see that there are overlapping subproblems in our solution and thus, we can use dynamic programming to optimize this. <br><br>       
import java.util.*;<br>
class knapsack<br>
{<br>
// m is size of coins array<br>
// (number of different coins)<br>
static int minCoins(int coins[], int m, int V)<br>
{<br>
// table[i] will be storing<br>
// the minimum number of coins<br>
// required for i value. So<br>
// table[V] will have result<br>
int table[] = new int[V + 1];<br>
<br>
// Base case (If given value V is 0)<br>
table[0] = 0;<br>
<br>
// Initialize all table values as Infinite<br>
for (int i = 1; i <= V; i++)<br>
table[i] = Integer.MAX_VALUE;<br>
<br>
// Compute minimum coins required for all<br>
// values from 1 to V<br>
for (int i = 1; i <= V; i++)<br>
{<br>
// Go through all coins smaller than i<br>
for (int j = 0; j < m; j++)<br>
if (coins[j] <= i)<br>
{<br>
int sub_res = table[i - coins[j]];<br>
if (sub_res != Integer.MAX_VALUE<br>
&& sub_res + 1 < table[i])<br>
table[i] = sub_res + 1;<br>
}<br>
}<br>
<br>
if(table[V]==Integer.MAX_VALUE)<br>
return -1;<br>
<br>
return table[V];<br>
<br>
}<br>
<br>
public static void main (String[] args)<br>
{<br>
Scanner s = new Scanner(System.in);<br>
System.out.println("Enter size of coin array:");<br>
int n = s.nextInt();<br>
int coins[] = new int[n];<br>
System.out.println("Enter the Coin Denomination:");<br>
for(int i=0 ; i<n ; i++)<br>
{<br>
coins[i] = s.nextInt();<br>
}<br>
System.out.println("Enter the Weight(Sum):");<br>
int sum = s.nextInt() ;<br>
System.out.println ( "Minimum coins required is "<br>
+ minCoins(coins, n, sum));<br>
}<br>
}<br><hr><br>
8. To write a JAVA program to perform Breadth First Search
Traversal for given graph.<br><br>
Aim: Program to implement Breadth First Search Traversal<br>
A standard BFS implementation puts each vertex of the graph into one of two<br>
categories:<br>
Visited<br>
Not Visited<br>
The purpose of the algorithm is to mark each vertex as visited while avoiding cycles.<br>
The algorithm works as follows:<br>
Step 1: Start by putting any one of the graph&#39;s vertices at the back of a queue.<br>
Step 2: Take the front item of the queue and add it to the visited list.<br>
Step 3: Create a list of that vertex&#39;s adjacent nodes. Add the ones which aren&#39;t in the<br>
visited list to the back of the queue.<br>
Step 4: Keep repeating steps 2 and 3 until the queue is empty.<br><br>
import java.io.*;<br>
import java.util.*;<br>
public class BFSTraversal<br>
{<br>
private int node; /* total number number of nodes in the graph */<br>
private LinkedList<Integer> adj[]; /* adjacency list */<br>
private Queue<Integer> que; /* maintaining a queue */<br>
BFSTraversal(int v)<br>
{<br>
node = v;<br>
adj = new LinkedList[node];<br>
for (int i=0; i<v; i++)<br>
{<br>
adj[i] = new LinkedList<>();<br>
}<br>
que = new LinkedList<Integer>();<br>
}<br>
void insertEdge(int v,int w)<br>
{<br>
adj[v].add(w); /* adding an edge to the adjacency list (edges<br>
are bidirectional in this example) */<br>
}<br>
void BFS(int n)<br>
{<br>
boolean nodes[] = new boolean[node]; /* initialize boolean<br>
array for holding the data */<br>
int a = 0;<br>
nodes[n]=true;<br>
que.add(n); /* root node is added to the top of the queue */<br>
while (que.size() != 0)<br>
{<br>
n = que.poll(); /* remove the top element of the queue */<br>
System.out.print(n+" "); /* print the top element of the queue<br>
*/<br>
for (int i = 0; i < adj[n].size(); i++) /* iterate through the<br>
linked list and push all neighbors into queue */<br>
{<br>
a = adj[n].get(i);<br>
if (!nodes[a]) /* only insert nodes into queue if they<br>
have not been explored already */<br>
{<br>
nodes[a] = true;<br>
que.add(a);<br>
}<br>
}<br>
}<br>
ublic static void main(String args[])<br>
{<br>
BFSTraversal graph = new BFSTraversal(6);<br>
graph.insertEdge(0, 1);<br>
graph.insertEdge(0, 3);<br>
graph.insertEdge(0, 4);<br>
graph.insertEdge(2, 5);<br>
graph.insertEdge(3, 5);<br>
graph.insertEdge(1, 4);<br>
graph.insertEdge(1, 0);<br>
graph.insertEdge(1, 1);<br>
graph.insertEdge(4, 1);<br>
graph.insertEdge(3, 1);<br>
graph.insertEdge(5, 4);<br>
graph.insertEdge(5, 3);<br>
System.out.println("Breadth First Traversal for the graph is:");<br>
graph.BFS(0);<br>
}<br>
}<br>








        </p>
    <button>Contact us</button>
    <hr>
    <table>
        <tr>
            <td>
                <p><strong>About Us</strong> <br>Frozen Creation is a set of developers, SEO experts, hardworking, and smartly skilled brains. Our services are trustworthy with the necessary skill sets which makes a brilliant digital approaching platform in this popping social media world.</p>
            </td>
            <td>
                <img src="index/About Us.jpg" alt="isn't available" width='30%'>
            </td>
        </tr>
    </table>
    <br>
    <br>
    <br>
    <br>
    <hr>
    <h2>You can trust our services in this <br> volcanic popping social media world.</h2>
    <br>
    <br>
    <h4>Hey! Want to stand out of crowd ? Here we are.</h4>
    <br>
    <button>Get Free Estimate</button>
    <hr>
    <br>
    <h2 align="center">Services</h2>
    <p align="center">As you know Frozen Creation is a multimedia digital marketing firm and it provides all the services under the same efficiency by fulfilling your expectations. <br> We work with the best strategies and reassures.</p>
    <br>
     <table>
        <tr>
                <td align="center"><img src="index/social media marketing.jpg" alt="social media marketing jpg" width="60%"><br>
                    <h3>social media marketing</h3><br>
                    <p align="center"> We will take care of your social <br> media for marketing purposes. From <br>creating creative posts with the help <br>of our highly skilled social media<br> managing experts and SEO experts<br> to posting, we will take your<br> professional account to next level.<br> We keep an analytical overview of<br> your account and page to target your<br> audience with engaging content.</p></td>
                <td align="center"><img src="index/commercial digital marketing.jpg" alt="commercial digital marketing jpg" width="60%"><br>
                    <h3>commercial digital marketing</h3><br>
                    <p align="center">Social media campaigns helps to <br>gain popularity and fame. We have <br>successfully created and executed <br>many social media marketing <br>campaigns on social media <br>channels. You can trust us with our<br> ideas to make your commercial<br> brand big in quality and gain fans<br> and followers around the globe.</p></td>
                <td align="center"><img src="index/social media management.jpg" alt="social media management jpg" width="60%"><br>
                    <h3>social media management</h3><br>
                    <p align="center">Trust us on daily posting on your <br>social media platforms. We will <br>advertise, publish, and manage your <br>internet presence with our toolset<br> which can help your social media <br>grow bigger and better. </p></td>     
                <td align="center"><img src="index/web development.jpg" alt="web development jpg" width="200%"><br>
                    <h3>web development</h3><br>
                    <p align="center">If you are looking to create a website <br>or account then you are in the right<br> place. We create websites and <br>maintain them as well. We assure to <br>create the most appealing<br> websites/accounts with our web <br>developers, designers, content<br> writers which work ac </p></td>
        </tr>
    </table>
    <br>
    <hr>
    <h2>Writing blogs based on digital marketing in our <br> way can be the next introduction of our <br> perspective to readers.</h2>
    <p> We are here, for you. We will make sure to cover all necessary things about digital marketing <br> with the possible skill set required to master it.</p>
    <br>
    <button>Read more</button>
    <br>
    <hr>
     
        <form action="">
            <h2>Weekly buzz!</h2>
            <p>Subscribe for an outright knowledge X Change</p>
            <label for="name">First name or full name</label><br>
            <input type="text" name="name" id="name"><br>
            <label for="email">Email</label><br>
            <input type="email" name="email" id="email"><br>
            <input type="checkbox" name="t&c" id="t&c">
            <label for="t&c">By continuing, you accept the privacy policy</label><br>
            <button>Subscribe Us!</button> 
            <br>
            <hr>
        </form>
   
    <footer>
       <h4>Copyright © 2021 Frozen Creation</h4> 
    </footer>
</body>
</html>
